
# 第六章：深入pandas：数据处理


# 6.4. 离散化与数据分箱

您将在本节中看到的一个更复杂的转换过程是离散化。有时可以使用它，特别是在一些实验案例中，来处理顺序生成的大量数据。然而，为了对数据进行分析，有必要将这些数据转换成离散的类型，例如，将这些读数的取值范围划分成更小的间隔，并计算其中的发生情况或统计数据。另一种情况是，由于对总体的精确采样会产生大量的样本。在这里，为了便于对数据的分析，也需要将值的范围划分为不同的类别，然后分析与每个类别相关的事件和统计数据。

例如，在您的示例中，您可以读取0到100之间的实验值。这些数据被收集在一个列表中。

```python
>>> results = [12,34,67,55,28,90,99,12,3,56,74,44,87,23,49,89,87]
```

你知道实验值在0到100之间; 因此，你可以均匀地把这个区间，例如，分成四等份。也就是所谓“分箱”。第一个包含0到25之间的值，第二个包含26到50之间的值，第三个包含51到75之间的值，最后一个包含76到100之间的值。要对pandas进行这个分箱，首先必须定义一个数组，其中包含箱体的分隔值:

```python
>>> bins = [0,25,50,75,100]
```

然后使用一个名为cut()的专门函数，并将results数组和bins数组传递其中。

```python
>>> cat = pd.cut(results, bins)
>>> cat
   (0, 25]
  (25, 50]
  (50, 75]
  (50, 75]
  (25, 50]
(75, 100]
(75, 100]
   (0, 25]
   (0, 25]
  (50, 75]
  (50, 75]
  (25, 50]
(75, 100]
   (0, 25]
  (25, 50]
(75, 100]
(75, 100]
Levels (4): Index(['(0, 25]', '(25, 50]', '(50, 75]', '(75, 100]'], dtype=object)
```
cut()函数返回的对象是Categorical类型的特殊对象。您可以将它看作一个字符串数组，指示各个箱体的名称。在内部，它包含一个categories数组，该数组指示不同内部类别的名称，以及一个codes数组，该数组包含一个与结果元素(即被分箱的数组)数量相等的一个数字列表。对应于被分配的相应箱体。

```python
>>> cat.categories
IntervalIndex([0, 25], (25, 50], (50, 75], (75, 100]]
               closed='right'
             dtype='interval[int64]')
>>> cat.codes
array([0, 1, 2, 2, 1, 3, 3, 0, 0, 2, 2, 1, 3, 0, 1, 3, 3], dtype=int8)
```

最后，要了解每个箱体的出现情况，即每个类别中有多少结果，必须使用value_counts()函数。

```python
>>> pd.value_counts(cat)
(75, 100]    5
(0, 25]      4
(25, 50]     4
(50, 75]     4
dtype: int64
```

如您所见，每个类都有带括号的下限和上限。这个符号与用来表示区间的数学符号一致。如果括号为方括号，则数字在范围内(闭区间)，如果括号为圆括号，则数字不在范围内(开区间)。

您可以通过首先在字符串数组中调用不同的箱体，然后在用于创建Categorical对象的cut()函数中分配标签选项，从而为不同的箱体命名。

```python
>>> bin_names = ['unlikely','less likely','likely','highly likely']
>>> pd.cut(results, bins, labels=bin_names)
      unlikely
   less likely
        likely
        likely
   less likely
 highly likely
 highly likely
      unlikely
      unlikely
        likely
        likely
   less likely
 highly likely
      unlikely
   less likely
 highly likely
 highly likely
Levels (4): Index(['unlikely', 'less likely', 'likely', 'highly likely'], dtype=object)
```

如果传递给cut()函数的参数是一个整数，而不是箱体的边界，将按照数字指定的许多间隔来划分数组的值范围。

区间的范围将由样本数据的最小值和最大值来取，即被分箱的数组的最小值和最大值。

```python
>>> pd.cut(results, 5)
(2.904, 22.2]
  (22.2, 41.4]
  (60.6, 79.8]
  (41.4, 60.6]
  (22.2, 41.4]
    (79.8, 99]
    (79.8, 99]
(2.904, 22.2]
(2.904, 22.2]
  (41.4, 60.6]
  (60.6, 79.8]
  (41.4, 60.6]
    (79.8, 99]
  (22.2, 41.4]
  (41.4, 60.6]
    (79.8, 99]
    (79.8, 99]
Levels (5): Index(['(2.904, 22.2]', '(22.2, 41.4]', '(41.4, 60.6]', '(60.6, 79.8]', '(79.8, 99]'], dtype=object)
```

除了cut()之外，pandas提供了另一种分箱方法:qcut()。这个函数将样本直接分为等分。实际上，根据数据样本的分布情况，通过使用cut()，每个箱体会有不同的出现次数。相反，qcut()将确保每个箱体的出现次数相等，但是每个箱体的边界是不同的。

```python
>>> quintiles = pd.qcut(results, 5)
>>> quintiles
    [3, 24]
   (24, 46]
(62.6, 87]
(46, 62.6]
   (24, 46]
   (87, 99]
   (87, 99]
    [3, 24]
    [3, 24]
(46, 62.6]
(62.6, 87]
   (24, 46]
(62.6, 87]
    [3, 24]
(46, 62.6]
   (87, 99]
(62.6, 87]
Levels (5): Index(['[3, 24]', '(24, 46]', '(46, 62.6]', '(62.6, 87]', '(87, 99]'], dtype=object)

>>> pd.value_counts(quintiles)
[3, 24]       4
(62.6, 87]    4
(87, 99]      3
(46, 62.6]    3
(24, 46]      3
dtype: int64
```

如您所见，在quintiles中，bin的边界间隔与cut()函数生成的边界不同。此外，如果您查看每个bin的出现情况，会发现qcut()试图标准化每个bin的出现情况，但是对于quintiles，前两个bin出现的次数更多，因为结果的数量不能被5整除。


## 检测和过滤异常值

在数据分析过程中，常常需要检测数据结构中是否存在异常值。举例来说，从1000个完全随机的值中创建三个列的dataframe:

```python
>>> randframe = pd.DataFrame(np.random.randn(1000,3))
With the describe() function you can see the statistics for each column.
>>> randframe.describe()
                 0            1            2
count  1000.000000  1000.000000  1000.000000
mean      0.021609    -0.022926    -0.019577
std       1.045777     0.998493     1.056961
min      -2.981600    -2.828229    -3.735046
25%      -0.675005    -0.729834    -0.737677
50%       0.003857    -0.016940    -0.031886
75%       0.738968     0.619175     0.718702
max       3.104202     2.942778     3.458472
```
例如，您可以考虑那些值大于标准偏差三倍的离群值。若要仅具有dataframe的每一列的标准偏差，请使用std()函数。

```python
>>> randframe.std()
0    1.045777
1    0.998493
2    1.056961
dtype: float64
```

现在应用dataframe的所有值的过滤，对每一列应用相应的标准差。由于有了any()函数，您可以在每个列上应用过滤器。

```python
>>> randframe[(np.abs(randframe) > (3*randframe.std())).any(1)]
            0         1         2
69  -0.442411 -1.099404  3.206832
576 -0.154413 -1.108671  3.458472
907  2.296649  1.129156 -3.735046
```


